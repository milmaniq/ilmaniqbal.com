<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description"
    content="Learn how Kubernetes ServiceAccounts and tokens work, how to use RBAC, and securely call services across namespaces." />
  <meta name="keywords"
    content="Kubernetes, K8s, ServiceAccount, RBAC, Tokens, JWT, Microservices, Namespaces, Cluster Security, Kubernetes tutorial, Kubernetes guide" />
  <meta name="author" content="Ilman Iqbal" />
  <title>Understanding Kubernetes Service Accounts, Tokens, and Cross-Namespace Access</title>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Understanding Kubernetes Service Accounts, Tokens, and Cross-Namespace Access",
      "author": {
          "@type": "Person",
          "name": "Ilman Iqbal",
          "url": "https://www.linkedin.com/in/ilman-iqbal-096308172"
      },
      "publisher": {
          "@type": "Organization",
          "name": "Ilman Iqbal",
          "url": "https://ilmaniqbal.com",
          "logo": {
              "@type": "ImageObject",
              "url": "https://ilmaniqbal.com/img/logo.png"
          }
      },
      "datePublished": "2025-11-08",
      "dateModified": "2025-11-08",
      "description": "Step-by-step guide to using Kubernetes ServiceAccounts, RBAC, tokens, and secure cross-namespace communication between pods.",
      "articleSection": ["Kubernetes ServiceAccounts", "RBAC", "Tokens", "JWT Validation", "Cross-Namespace Communication"],
      "inLanguage": "en",
      "keywords": "Kubernetes, K8s, ServiceAccount, RBAC, Tokens, JWT, Microservices, Namespaces, Cluster Security, Kubernetes tutorial, Kubernetes guide",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ilmaniqbal.com/kubernetes-service-accounts-tokens.html"
      }
    }
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap" rel="stylesheet" />
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/blog.css" rel="stylesheet">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8PPCHX9PDV"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-8PPCHX9PDV');
  </script>
</head>

<body>
  <div class="container">

    <header class="site-header">
      <a href="index.html" class="site-logo-wrapper" style="text-decoration: none; color: inherit;">
        <div class="site-logo"><i class="fas fa-code fa-2x"></i></div>
        <h1>Ilman Iqbal's Blog</h1>
      </a>
    </header>

    <h2 class="tm-post-title">Understanding Kubernetes Service Accounts, Tokens, and Cross-Namespace Access</h2>
    <p class="meta">Nov 8, 2025 posted by Ilman Iqbal</p>

    <p>
      When you deploy applications on Kubernetes, your pods often need to communicate with other services. To do this
      securely, Kubernetes provides a built-in identity and authorization system through Service Accounts and RBAC
      (Role-Based Access Control). This post breaks down what these are, why they matter, and how to use them to make
      authenticated calls between workloads — including across namespaces.
    </p>

    <img id="half-width" width="50%" src="img/k8s_sa-1.png" alt="mysql-to-snowflake-data-migration-airbyte" />

    <h3>The Problem: Identity inside the Cluster</h3>
    <p>
      Every pod has no identity other than its IP by default. To call another pod or list resources, there must be a
      trusted identity associated with the pod. This is where Service Accounts come in.
    </p>

    <h3>What is a Service Account?</h3>
    <p>
      A ServiceAccount (SA) is an identity assigned to a pod. Each namespace automatically has a default SA. When you
      create a pod or a deployment, if you don’t specify a service account, it uses default.
    </p>
    <p>
      Each ServiceAccount comes with:
    </p>
    <ul>
      <li>A token - a signed JSON Web Token (JWT) that identifies it.</li>
      <li>A certificate to verify the Kubernetes API identity</li>
      <li>A namespace it belongs to</li>
    </ul>
    <p>
      These credentials are mounted inside pods at <code>/var/run/secrets/kubernetes.io/serviceaccount/</code>:
    </p>
    <ul>
      <li><code>ca.crt</code> → Cluster’s public CA certificate</li>
      <li><code>namespace</code> → The namespace of the pod</li>
      <li><code>token</code> → JWT token used for authentication</li>
    </ul>
    <p>This token is a JWT (JSON Web Token) signed by the Kubernetes API server. It is yours pods identity and is
      automatically rotated and managed by Kubernetes.</p>

    <h3>Why Do We Need RBAC?</h3>
    <p>
      Role-Based Access Control defines what a ServiceAccount can do. Without RBAC, all SAs would have unrestricted
      access.
    </p>
    <p>RBAC is built from three main components:</p>
    <ul>
      <li>Role → defines permissions (get, list, watch, create)</li>
      <li>RoleBinding → attaches a Role to an SA</li>
      <li>ClusterRole/ClusterRoleBinding → same as above but cluster-wide instead of namespaced</li>
    </ul>

    <p>
      Using ServiceAccounts with RBAC provides:
    </p>
    <ul>
      <li>Fine-grained control — limit what each workload can do</li>
      <li>Auditability — all API calls are logged with the ServiceAccount identity</li>
      <li>Zero Trust — each component proves who it is on every call</li>
      <li>Security best practices — no hardcoded tokens, no shared secrets.</li>
    </ul>

    <p>This is the core of Kubernetes in-cluster security and the foundation for secure workload-to-workload
      communication.</p>

    <h3>Calling One Pod from another inside a Kubernetes Cluster</h3>
    <p>
      Example scenario:
    </p>
    <ul>
      <li><strong>curl-app</strong> (namespace: client-ns) → calls <strong>receiver-app</strong></li>
      <li><strong>receiver-app</strong> (namespace: server-ns) → runs an http server</li>
    </ul>

    <h4>Step 1: Create Namespaces</h4>
    <pre><code>kubectl create namespace client-ns
kubectl create namespace server-ns</code></pre>

    <h4>Step 2: Deploy Receiver in server-ns</h4>
    <p>This will be the service we’re calling. It uses a simple python container that prints the request headers.</p>
    <p>
      File: <code>receiver-deploy.yaml</code>
    </p>
    <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: receiver-app
  namespace: server-ns
spec:
  replicas: 1
  selector:
    matchLabels:
      app: receiver-app
  template:
    metadata:
      labels:
        app: receiver-app
    spec:
      containers:
        - name: receiver
          image: python:3.11-slim
          command: ["python3", "-m", "http.server", "8080"]
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: receiver-svc
  namespace: server-ns
spec:
  selector:
    app: receiver-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080</code></pre>

    <p>Apply it:</p>
    <pre><code>kubectl apply -f receiver-deploy.yaml</code></pre>

    <p>This creates a simple service - <code>receiver-svc.server-ns.svc.cluster.local</code></p>

    <h4>Step 3: Deploy Curl App in client-ns</h4>
    <p>This app will simulate another microservice making a request inside the cluster.</p>
    <p>File: <code>curl-deploy.yaml</code></p>
    <pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
  name: curl-sa
  namespace: client-ns
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: curl-role
  namespace: client-ns
rules:
  - apiGroups: [""]
    resources: ["pods", "services"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: curl-rolebinding
  namespace: client-ns
subjects:
  - kind: ServiceAccount
    name: curl-sa
    namespace: client-ns
roleRef:
  kind: Role
  name: curl-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: curl-app
  namespace: client-ns
spec:
  replicas: 1
  selector:
    matchLabels:
      app: curl-app
  template:
    metadata:
      labels:
        app: curl-app
    spec:
      serviceAccountName: curl-sa
      containers:
        - name: curl
          image: curlimages/curl:8.8.0
          command: ["sleep", "3600"]</code></pre>

    <p>Apply it:</p>
    <pre><code>kubectl apply -f curl-deploy.yaml</code></pre>

    <h5>Why ServiceAccounts and RBAC Matter?</h3>
      <p>Even though this example just uses curl, it’s best practice for every app in Kubernetes to use its own
        ServiceAccount instead of the default one.</p>
      <ul>
        <li>ServiceAccount = identity of the pod within the cluster.</li>
        <li>RBAC (Role-Based Access Control) = defines what that identity can do.</li>
      </ul>

      <p>In production, this prevents accidental privilege escalations or unauthorized API calls between namespaces.</p>

      <p>Here:</p>
      <ul>
        <li>curl-sa gives the pod an identity.</li>
        <li>curl-role restricts permissions to only list and get pods/services.</li>
        <li>curl-rolebinding attaches the role to that service account.</li>
      </ul>

      <p>This mirrors real-world microservice security principles: least privilege and explicit access.</p>

      <h4>Step 4: Test and View the Headers</h4>
      <p>Now exec into the receiver pod and watch its logs in real time: </p>
      <pre><code>kubectl logs -n server-ns -f deploy/receiver-app</code></pre>
      <p>Now let’s exec into the curl-app pod and call the receiver: </p>
      <pre><code>kubectl exec -it -n client-ns deploy/curl-app -- sh
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -v -H "Authorization: Bearer $TOKEN" http://receiver-svc.server-ns.svc</code></pre>

      <p class="note">Note: Using the full FQDN (<code>receiver-svc.server-ns.svc.cluster.local</code>) can sometimes
        fail in minimal
        container
        images (like BusyBox or curlimages/curl) due to resolver quirks, so the shorter DNS name (<code>.svc</code>) is
        more reliable for in-cluster communication.</p>

      <p>You’ll see something like this in the logs:</p>
      <pre><code>10.1.0.15 - - [08/Nov/2025 13:21:40] "GET / HTTP/1.1" 200 -
Host: receiver-svc.server-ns.svc
User-Agent: curl/8.8.0
Accept: */*
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...</code></pre>

      <h4>Step 5: Decode and Inspect the Token</h4>
      <p>Copy the JWT to jwt.io, you’ll see claims like:</p>
      <pre><code>{
  "aud": [
    "https://kubernetes.default.svc.cluster.local",
    "k3s"
  ],
  "exp": 1794149282,
  "iss": "https://kubernetes.default.svc.cluster.local",
  "kubernetes.io": {
    "namespace": "client-ns",
    "serviceaccount": {
      "name": "curl-sa",
      "uid": "4a407f99-d81c-4c65-b5d9-50214ec1ba38"
    }
  },
  "sub": "system:serviceaccount:client-ns:curl-sa"
}</code></pre>

      <p>That’s exactly how we enforce trust between services in Kubernetes.</p>

      <h5>Token Verification using JWKS</h5>
      <p>Kubernetes exposes its signing keys at the OpenID Connect discovery endpoint if your cluster has OIDC enabled.
        You can find the jwks_uri by executing the following:</p>
      <pre><code>TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -k -H "Authorization: Bearer $TOKEN" https://kubernetes.default.svc/.well-known/openid-configuration</code></pre>

      <p>This returns a JSON containing jwks_uri:</p>
      <pre><code>{
  "issuer": "https://kubernetes.default.svc.cluster.local",
  "jwks_uri": "https://172.21.0.3:6443/openid/v1/jwks"
}</code></pre>

      <p>The jwks_uri can be used by apps to fetch public keys to validate JWTs locally.</p>

      <p class="note">Note: Kubernetes exposes the API server as a ClusterIP service called kubernetes in the default
        namespace. So, the DNS name would be kubernetes.default.svc. All pods in the cluster can reach the API server
        using either the ClusterIP or the DNS name. Using <code>https://kubernetes.default.svc/openid/v1/jwks</code> is
        preferred in-cluster because it’s DNS-based, automatically resolves, no hardcoding.</p>

</body>

</html>